from typing import Callable, List, Optional, Tuple

import gym
import pytest

from common.config import Config
from common.transforms import ChannelsFirstIfNeeded, ToTensor, Transforms
from conftest import xfail_param
from utils.utils import take

from .continual_rl_setting import ContinualRLSetting

def test_basic(config: Config):
    setting = ContinualRLSetting(dataset="breakout")
    batch_size = 4
    env = setting.train_dataloader(batch_size=batch_size)
    observations = env.reset()

    for i in range(5):
        actions = env.action_space.sample()
        observations, rewards, done, info = env.step(actions)

        assert isinstance(observations, ContinualRLSetting.Observations)
        assert observations.x.shape == (batch_size, 210, 160, 3)
        assert observations.task_labels is None

        # TODO: Is this what we want? Could the reward or actions ever change?
        assert isinstance(rewards, ContinualRLSetting.Rewards)
        assert rewards.y.shape == (batch_size,)
        
        env.render("human")
        
        if all(done):
            break
    env.close()



@pytest.mark.parametrize("batch_size", [1, 3])
@pytest.mark.parametrize(
    "dataset, expected_obs_shape", [
        ("CartPole-v0",  (400, 600, 3)),
    ],
)
def test_check_iterate_and_step(dataset: str,
                                expected_obs_shape: Tuple[int, ...],
                                batch_size: int):
    """ Test that the observations are of the right type and shape, regardless
    of wether we iterate on the env by calling 'step' or by using it as a
    DataLoader.
    """
    setting = ContinualRLSetting(dataset=dataset)
    
    expected_obs_batch_shape = (batch_size, *expected_obs_shape)

    # Test the shapes of the obs generated by the train/val/test dataloaders.
    dataloader_methods = [
        setting.train_dataloader,
        setting.val_dataloader,
        setting.test_dataloader
    ]
    for dataloader_method in dataloader_methods:
        dataloader = dataloader_method(batch_size=batch_size)
        
        reset_obs = dataloader.reset()
        assert isinstance(reset_obs, ContinualRLSetting.Observations)
        assert reset_obs.x.shape == expected_obs_batch_shape
        
        step_obs, *_ = dataloader.step(dataloader.random_actions())
        assert isinstance(step_obs, ContinualRLSetting.Observations)
        assert step_obs.x.shape == expected_obs_batch_shape
        
        # TODO: this is still not the right type
        for (iter_obs, _) in take(dataloader, 3):
            assert isinstance(iter_obs, ContinualRLSetting.Observations)
            assert iter_obs.shape == expected_obs_batch_shape
            reward = dataloader.send(dataloader.random_actions())


@pytest.mark.xfail(reason=f"TODO: DQN model only accepts string environment names...")
def test_dqn_on_env():
    """ TODO: Would be nice if we could have the models work directly on the
    gym envs..
    """
    from pl_bolts.models.rl import DQN
    from pytorch_lightning import Trainer
    setting = ContinualRLSetting(observe_state_directly=False)
    env = setting.train_dataloader(batch_size=5)
    model = DQN("PongNoFrameskip-v4")
    trainer = Trainer(fast_dev_run=True)
    trainer.fit(model)
    assert False
