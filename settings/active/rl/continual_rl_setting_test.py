from typing import Callable, List, Optional, Tuple

import gym
import pytest

from common.config import Config
from common.transforms import ChannelsFirstIfNeeded, ToTensor, Transforms
from conftest import xfail_param
from utils.utils import take

from .continual_rl_setting import ContinualRLSetting

def test_basic(config: Config):
    setting = ContinualRLSetting(dataset="breakout")
    batch_size = 4
    env = setting.train_dataloader(batch_size=batch_size)
    observations = env.reset()
        
    for i in range(5):
        actions = env.action_space.sample()
        observations, rewards, done, info = env.step(actions)
        
        assert isinstance(observations, ContinualRLSetting.Observations)
        assert observations.x.shape == (batch_size, 3, 210, 160)
        
        if setting.smooth_task_boundaries:
            assert observations.task_labels is None or all(label is None for label in observations.task_labels)
        elif setting.task_labels_at_train_time:
            assert observations.task_labels is not None and all(label is not None for label in observations.task_labels)
            assert all(task_id == 0 for task_id in observations.task_labels)

            
        # TODO: Is this what we want? Could the reward or actions ever change?
        assert isinstance(rewards, ContinualRLSetting.Rewards)
        assert rewards.y.shape == (batch_size,)
        
        env.render("human")
        
        if all(done):
            break
    env.close()



@pytest.mark.parametrize("batch_size", [1, 3])
@pytest.mark.parametrize(
    "dataset, expected_obs_shape", [
        ("CartPole-v0",  (3, 400, 600)),
        # ("duckietown", (120, 160, 3)),
    ],
)
def test_check_iterate_and_step(dataset: str,
                                expected_obs_shape: Tuple[int, ...],
                                batch_size: int):
    """ Test that the observations are of the right type and shape, regardless
    of wether we iterate on the env by calling 'step' or by using it as a
    DataLoader.
    """
    setting = ContinualRLSetting(dataset=dataset)
    
    expected_obs_batch_shape = (batch_size, *expected_obs_shape)

    # Test the shapes of the obs generated by the train/val/test dataloaders.
    dataloader_methods = [
        setting.train_dataloader,
        setting.val_dataloader,
        setting.test_dataloader
    ]
    for dataloader_method in dataloader_methods:
        print(f"Testing dataloader method {dataloader_method.__name__}")
        dataloader = dataloader_method(batch_size=batch_size)
        
        reset_obs = dataloader.reset()
        assert isinstance(reset_obs, ContinualRLSetting.Observations)
        assert reset_obs.x.shape == expected_obs_batch_shape
        
        step_obs, *_ = dataloader.step(dataloader.action_space.sample())
        assert isinstance(step_obs, ContinualRLSetting.Observations)
        assert step_obs.x.shape == expected_obs_batch_shape
        
        # TODO: this is still not the right type, and for some reason it
        # receives `None` as a second item in the batch ?
        for iter_obs in take(dataloader, 3):
            assert isinstance(iter_obs, ContinualRLSetting.Observations)
            assert iter_obs.x.shape == expected_obs_batch_shape
            reward = dataloader.send(dataloader.action_space.sample())


@pytest.mark.xfail(reason=f"TODO: DQN model only accepts string environment names...")
def test_dqn_on_env():
    """ TODO: Would be nice if we could have the models work directly on the
    gym envs..
    """
    from pl_bolts.models.rl import DQN
    from pytorch_lightning import Trainer
    setting = ContinualRLSetting(observe_state_directly=False)
    env = setting.train_dataloader(batch_size=5)
    model = DQN("PongNoFrameskip-v4")
    trainer = Trainer(fast_dev_run=True)
    trainer.fit(model)
    assert False
